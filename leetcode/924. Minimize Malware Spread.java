/*
图论
Union Find

Step:
1. Build a union find graph
2. For each number in initial, build a map that records for each node, who can be spread to this node
3. Calculate which points can only be spread from each node in initial
4. Record the node with most elements that can only be spread from the node

ex: 
For graph like this:

   6 -- 0 -- 4    3    7   10
        |    |  / |    |
        |    |/   |    |
        5 -- 2 -- 1    8 -- 9

and initial = [0, 1, 7]
0 is connected to [0, 1, 2, 3, 4, 5, 6]
1 is connected to [0, 1, 2, 3, 4, 5, 6]
7 is connected to [7, 8, 9]

so the map will be:
0 - [0, 1]
1 - [0, 1]
2 - [0, 1]
3 - [0, 1]
4 - [0, 1]
5 - [0, 1]
6 - [0, 1]
7 - [7]
8 - [7]
9 - [7]

Loop the map, the resValue for 0 is 0, resValue for 1 is 0, resValue for 7 is 2, so ans = 7.


TC: O(n^2)
SC: O(n^2)
*/

class Solution {
    
    class UnionFind {
        int[] father;
        
        public UnionFind(int n) {
            this.father = new int[n];
            for(int i = 0; i < n; i++) {
                father[i] = i;
            }
        }
        
        public int find(int x) {
            if(x==father[x]) {
                return x;
            }
            return father[x] = find(father[x]);
        }
        
        public void connect(int a, int b) {
            int rootA = find(a);
            int rootB = find(b);
            if(rootA!=rootB) {
                father[rootA] = rootB;
            }
        }
        
        public boolean isConnected(int a, int b) {
            int rootA = find(a);
            int rootB = find(b);
            return rootA==rootB;
        }
    }
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        UnionFind uf = new UnionFind(n);
        for(int i = 0; i < n; i++) {
            for(int j = i; j < n; j++) {
                if(graph[i][j]==1) {
                    uf.connect(i, j);
                }
            }
        }
        Map<Integer, List<Integer>> map = new HashMap<>();
        for(int init : initial) {
            for(int i = 0; i < n; i++) {
                if(uf.isConnected(init, i)) {
                    if(!map.containsKey(i)) {
                        map.put(i, new ArrayList<>());
                    }
                    map.get(i).add(init);
                }
            }
        }
        int res = -1;
        int resValue = -1;
        for(int init : initial) {
            int temp = 0;
            for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {
                if(entry.getValue().size()==1 && entry.getValue().get(0)==init) {
                    temp++;
                }
            }
            if(res==-1 || resValue<temp || (resValue==temp && init<res)) {
                res = init;
                resValue = temp;
            }
        }
        return res;
    }
}