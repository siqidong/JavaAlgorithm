/*
图论
Union Find / DFS / BFS

I literally think this should be a medium problem...

For each node in initial, calculate how many nodes can be spread without that node.
When calculating how many nodes will be spread, this becomes a easy BFS/DFS problem.

The following code is using BFS

TC: O(n^3)
SC: O(n^2)
*/
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int res = -1;
        int resValue = -1;
        for(int init : initial) {
            int temp = getSpreadNumber(graph, initial, init);
            if(res==-1 || temp<resValue || (resValue==temp && init<res)) {
                res = init;
                resValue = temp;
            }
        }
        return res;
    }
    
    public int getSpreadNumber(int[][] graph, int[] initial, int curr) {
        int n = graph.length;
        Queue<Integer> queue = new LinkedList<>();
        Set<Integer> set = new HashSet<>();
        for(int init : initial) {
            if(init!=curr) {
                queue.offer(init);
                set.add(init);
            }
        }
        while(!queue.isEmpty()) {
            int node = queue.poll();
            for(int i = 0; i < n; i++) {
                int val = graph[node][i];
                if(val==0 || i==curr || set.contains(i)) {
                    continue;
                }
                queue.offer(i);
                set.add(i);
            }
        }
        return set.size();
    }
}

